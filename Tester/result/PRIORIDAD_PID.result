A: [MESSAGETO C]-> A{TICK|SEND(MSG,C)} B{--} C{--}
B: [MESSAGETO C]-> A{--} B{TICK|SEND(MSG,C)} C{--}
C: [RECEIVE]-> A{--} B{--} C{RECEIVE(MSG,A)|TICK}
C: [RECEIVE]-> A{--} B{--} C{RECEIVE(MSG,B)|TICK}
C: [MESSAGETO A]-> A{--} B{--} C{TICK|SEND(MSG,A)}
A: [RECEIVE]-> A{RECEIVE(MSG,C)|TICK} B{--} C{--}
# Despues de una fase inicial los relojes
# lógicos se han intercambiado.
A: [GETCLOCK]-> A{LC[2,1,3]} B{--} C{--}
B: [GETCLOCK]-> A{--} B{LC[0,1,0]} C{--}
C: [GETCLOCK]-> A{--} B{--} C{LC[1,1,3]}
# A y C compiten entre si.
C: [LOCK SEM]-> A{--} B{--} C{TICK|SEND(LOCK,A)|SEND(LOCK,B)}
A: [LOCK SEM]-> A{TICK|SEND(LOCK,B)|SEND(LOCK,C)} B{--} C{--}
# Los dos eventos son concurrentes (no se
# puede determinar precedencia). Gana A (por
# tener menor número de proceso).
# B (OK a los dos)
B: [RECEIVE]-> A{--} B{RECEIVE(LOCK,C)|TICK|TICK|SEND(OK,C)} C{--}
B: [RECEIVE]-> A{--} B{RECEIVE(LOCK,A)|TICK|TICK|SEND(OK,A)} C{--}
# A no responde a C.
A: [RECEIVE]-> A{RECEIVE(LOCK,C)|TICK} B{--} C{--}
# C Responde OK a A
C: [RECEIVE]-> A{--} B{--} C{RECEIVE(LOCK,A)|TICK|TICK|SEND(OK,A)}
# A Recibe todos los OK (B y C: Entra)
A: [RECEIVE]-> A{RECEIVE(OK,B)|TICK} B{--} C{--}
A: [RECEIVE]-> A{RECEIVE(OK,C)|TICK|MUTEX(SEM)} B{--} C{--}
A: [EVENT]-> A{TICK} B{--} C{--}
A: [UNLOCK SEM]-> A{TICK|SEND(OK,C)} B{--} C{--}
# C Recibe todos los OK (B y A: Entra)
C: [RECEIVE]-> A{--} B{--} C{RECEIVE(OK,B)|TICK}
C: [RECEIVE]-> A{--} B{--} C{RECEIVE(OK,A)|TICK|MUTEX(SEM)}
C: [UNLOCK SEM]-> A{--} B{--} C{--}
A: [GETCLOCK]-> A{LC[8,5,6]} B{--} C{--}
B: [GETCLOCK]-> A{--} B{LC[3,5,4]} C{--}
C: [GETCLOCK]-> A{--} B{--} C{LC[8,5,8]}
